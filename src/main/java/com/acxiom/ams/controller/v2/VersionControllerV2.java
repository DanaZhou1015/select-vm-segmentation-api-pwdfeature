package com.acxiom.ams.controller.v2;

import com.acxiom.ams.common.exception.AMSException;
import com.acxiom.ams.common.exception.AMSInvalidInputException;
import com.acxiom.ams.model.dto.DuplicateVersionDTO;
import com.acxiom.ams.model.dto.v2.VersionDTOCreate;
import com.acxiom.ams.model.dto.v2.VersionDTOUpdateTaxonomy;
import com.acxiom.ams.model.dto.v2.VersionDatasourceDTO;
import com.acxiom.ams.model.dto.v2.VersionDtoDelete;
import com.acxiom.ams.model.vo.VersionVo;
import com.acxiom.ams.service.VersionPoService;

import java.util.List;

import javax.validation.Valid;

import org.hibernate.validator.constraints.Range;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.validation.annotation.Validated;
import org.springframework.web.bind.annotation.*;

/**
 * Created by cldong on 3/21/2018.
 * add for new version table
 */
@RestController
@Validated
@RequestMapping(value = "/v2/version")
public class VersionControllerV2 {
    @Autowired
    VersionPoService versionPoService;

    @PostMapping(value = "/duplicate")
    public Long duplicateVersionById(@RequestBody DuplicateVersionDTO duplicateVersionDTO) throws AMSInvalidInputException {
        return versionPoService.duplicateVersionById(duplicateVersionDTO.getVersionId(), duplicateVersionDTO.getUsername());
    }

    @GetMapping(value = "/{tenantId}")
    public List<VersionVo> findVersionByTenantId(@PathVariable(value = "tenantId") Long tenantId) throws AMSInvalidInputException {
        return versionPoService.findByTenant(tenantId);
    }

    @GetMapping(value = "/{tenantId}/{versionId}")
    public VersionVo findVersionByTenantIdAndVersionId(@PathVariable(value = "tenantId") Long tenantId,
                                                       @PathVariable(value = "versionId") Long versionId) throws AMSInvalidInputException {
        return versionPoService.findByTenantAndId(tenantId, versionId);
    }

    @PostMapping(value = "/{tenantId}")
    public Long createVersion(@PathVariable(value = "tenantId") Long tenantId,
                              @RequestBody @Valid VersionDTOCreate versionDTOCreate) throws AMSInvalidInputException {
        return versionPoService.createVersion(versionDTOCreate, tenantId);
    }

    @PutMapping(value = "/{tenantId}")
    public void updateVersionAndTaxonomy(@PathVariable(value = "tenantId") Long tenantId,
                                         @RequestBody @Valid VersionDTOUpdateTaxonomy versionDTOUpdateTaxonomy)
            throws AMSException {
        versionPoService.updateVersion(versionDTOUpdateTaxonomy, tenantId);
    }

    @DeleteMapping(value = "/{tenantId}")
    public void deleteVersionAndTaxonomy(@PathVariable(value = "tenantId") Long tenantId,
                                         @RequestBody VersionDtoDelete versionDtoDelete) throws AMSException {
        versionPoService.deleteVersionByIdList(tenantId, versionDtoDelete);
    }

    @PutMapping(value = "/flag/{tenantId}/{versionId}/{activeFlag}")
    public void updateVersionFlag(@PathVariable(value = "tenantId") Long tenantId,
                                  @PathVariable(value = "versionId") Long versionId, @PathVariable(value =
            "activeFlag") @Range(min = 0, max = 2, message = "{message.error.version.activeFlag.range}") Integer activeFlag) throws AMSInvalidInputException {
        versionPoService.updateVersionFlag(tenantId, versionId, activeFlag);
    }

    @DeleteMapping(value = "/{tenantId}/{versionId}")
    public void deleteVersionById(@PathVariable(value = "tenantId") Long tenantId,
                                  @PathVariable(value = "versionId") Long versionId) throws AMSInvalidInputException {
        versionPoService.deleteVersionById(tenantId, versionId);
    }

    @PostMapping(value = "/{versionId}/{syncFlag}")
    public void updateSyncFlagById(@PathVariable(value = "versionId") Long versionId, @PathVariable(value = "syncFlag") Integer syncFlag) {
        versionPoService.updateSyncFlagById(syncFlag, versionId);
    }

    /**
     * @Author: Fermi.Tang
     * @Description: get tree id generated by datasource
     * @Date: 6/5/2018 11:44 AM
     * @Param: [datasourceId]
     * @Return: java.util.List<com.acxiom.ams.model.vo.VersionVo>
     */
    @GetMapping(value = "/list/{datasourceId}")
    public List<VersionVo> listVersionByDatasourceId(@PathVariable(value = "datasourceId") Integer datasourceId) {
        return versionPoService.listVersionByDatasourceId(datasourceId);
    }

    @GetMapping(value = "/tenant/path/{versionId}")
    public String listTenantPathByIds(@PathVariable(value = "versionId") Long versionId) throws AMSInvalidInputException {
        return versionPoService.listTenantPathByIds(versionId);
    }

    @PostMapping(value = "/by/datasourceIds")
    public List<VersionDatasourceDTO> findVersionByDatasourceIds(
            @RequestBody List<String> datasourceIds) {
        return versionPoService.findVersionIdsByDatasourceIds(datasourceIds);
    }
}
